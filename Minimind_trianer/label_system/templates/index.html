<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾åƒç±»æ ‡æ³¨å¹³å°</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .image-container {
            overflow: hidden;
            display: flex;
            background-color: #f3f4f6;
            border-radius: 0.5rem;
            position: relative;
            user-select: none;
            touch-action: none;
        }
        .image-container img {
            margin: auto;
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            -webkit-user-drag: none;
            user-select: none;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 h-screen flex flex-col">

<div id="app" class="flex flex-col h-full">
    <!-- Header -->
    <header class="bg-white shadow p-4 flex justify-between items-center z-10">
        <h1 class="text-xl font-bold text-indigo-600">å›¾åƒç±»æ ‡æ³¨å¹³å°</h1>
        <div class="flex items-center gap-4">
            <button onclick="window.location.href='http://localhost:5173/'" class="bg-blue-600 text-white px-4 py-2 rounded-lg font-medium text-sm hover:bg-blue-700 transition-colors flex items-center gap-1">
                åˆ‡æ¢åˆ°æ–‡æœ¬ç±»æ ‡æ³¨å¹³å°
            </button>
            <div class="h-6 w-px bg-gray-300 mx-2"></div>
            <div class="text-sm text-gray-500">
                å·²æ ‡æ³¨: <span class="font-bold text-green-600">{{ labeledCount }}</span> / {{ totalImages }}
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex-1 flex overflow-hidden">
        <!-- Sidebar (Project & Image List) -->
        <div class="w-80 bg-white border-r flex flex-col hidden md:flex">
            <!-- Project Configuration -->
            <div class="p-4 border-b bg-gray-50 flex flex-col gap-3">
                <div class="font-bold text-gray-700 flex justify-between items-center">
                    <span>é¡¹ç›®é…ç½®</span>
                    <button @click="clearForm" class="text-xs text-blue-600 hover:underline">é‡ç½®è¡¨å•</button>
                </div>
                
                <!-- Project Selector -->
                <select v-model="currentProjectId" @change="onProjectSwitch" class="w-full border border-gray-300 rounded px-2 py-1 text-sm">
                    <option value="" disabled>-- é€‰æ‹©é¡¹ç›® --</option>
                    <option v-for="p in projects" :key="p.id" :value="p.id">{{ p.name }}</option>
                </select>

                <!-- Project Inputs -->
                <div class="flex flex-col gap-2">
                    <input v-model="projectForm.name" placeholder="é¡¹ç›®åç§°" class="w-full border border-gray-300 rounded px-2 py-1 text-sm">
                    
                    <div class="flex gap-1">
                        <input v-model="projectForm.image_dir" placeholder="å›¾ç‰‡æ–‡ä»¶å¤¹è·¯å¾„" class="flex-1 border border-gray-300 rounded px-2 py-1 text-sm">
                        <button @click="selectImageDir" class="bg-gray-200 hover:bg-gray-300 px-2 rounded text-xs" title="é€‰æ‹©æ–‡ä»¶å¤¹">ğŸ“‚</button>
                    </div>

                    <div class="flex gap-1">
                        <input v-model="projectForm.jsonl_path" placeholder="è¾“å‡º JSONL æ–‡ä»¶å¤¹" class="flex-1 border border-gray-300 rounded px-2 py-1 text-sm">
                        <button @click="selectJsonlPath" class="bg-gray-200 hover:bg-gray-300 px-2 rounded text-xs" title="é€‰æ‹©æ–‡ä»¶å¤¹">ğŸ“‚</button>
                    </div>
                </div>

                <!-- Actions -->
                <div class="flex gap-2">
                    <button @click="saveProject" class="flex-1 bg-indigo-600 text-white px-2 py-1 rounded text-sm hover:bg-indigo-700">ä¿å­˜/æ–°å»º</button>
                    <button @click="deleteProject" :disabled="!currentProjectId" class="flex-1 bg-red-500 text-white px-2 py-1 rounded text-sm hover:bg-red-600 disabled:opacity-50">åˆ é™¤</button>
                </div>
            </div>

            <!-- Image List Header -->
            <div class="p-2 bg-gray-100 border-b text-xs font-bold text-gray-500 flex justify-between items-center">
                <span>å›¾ç‰‡åˆ—è¡¨ ({{ images.length }})</span>
                <button @click="fetchImages" class="text-indigo-600 hover:text-indigo-800" title="åˆ·æ–°åˆ—è¡¨">â†»</button>
            </div>

            <!-- Image List -->
            <div class="flex-1 overflow-y-auto">
                <div v-for="(img, index) in images" :key="img" 
                     @click="selectImage(index)"
                     class="p-2 cursor-pointer hover:bg-gray-100 text-sm truncate flex justify-between items-center"
                     :class="{'bg-indigo-50 border-l-4 border-indigo-600': currentIndex === index, 'text-green-600': isLabeled(img)}">
                    <span :title="img">{{ img }}</span>
                    <span v-if="isLabeled(img)" class="text-xs">âœ“</span>
                </div>
            </div>
        </div>

        <!-- Workspace -->
        <div class="flex-1 flex flex-col md:flex-row p-4 gap-4 overflow-hidden">
            
            <!-- Image View -->
            <div class="flex-1 flex flex-col min-w-0">
                <div class="image-container flex-1 shadow-inner border border-gray-200 relative group"
                     ref="imageContainerRef"
                     :class="rightMode === 'box' && boxCreateActive ? 'cursor-crosshair' : ''"
                     @pointerdown="onImagePointerDown"
                     @pointermove="onImagePointerMove"
                     @pointerup="onImagePointerUp"
                     @pointercancel="onImagePointerCancel"
                     @pointerleave="onImagePointerLeave">
                    <img v-if="currentImageName" 
                         ref="imageRef"
                         :src="getImageUrl(currentImageName)" 
                         alt="Current Image"
                         draggable="false"
                         @load="onImageLoad"
                         @dragstart.prevent
                         class="max-w-full max-h-full object-contain">
                    <template v-if="currentImageName">
                        <div v-for="(b, idx) in boxesForCurrentImage"
                             :key="'fixed-' + idx"
                             class="absolute border-2 pointer-events-none"
                             :style="[
                                 boxStyleFromImagePixels(b, 10),
                                 { 
                                     borderColor: getLabelColor(b.label),
                                     backgroundColor: getLabelColor(b.label) + '20'
                                 }
                             ]">
                            <!-- Corner points -->
                            <div class="absolute w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: getLabelColor(b.label), top: '-3px', left: '-3px' }"></div>
                            <div class="absolute w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: getLabelColor(b.label), top: '-3px', right: '-3px' }"></div>
                            <div class="absolute w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: getLabelColor(b.label), bottom: '-3px', left: '-3px' }"></div>
                            <div class="absolute w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: getLabelColor(b.label), bottom: '-3px', right: '-3px' }"></div>
                        </div>
                        <div v-if="drawing && currentBox"
                             ref="drawingBoxRef"
                             class="absolute border-2 pointer-events-none"
                             :style="[
                                 boxStyleFromImagePixels(currentBox, 20, true),
                                 { 
                                     borderColor: getLabelColor(currentBox.label),
                                     backgroundColor: getLabelColor(currentBox.label) + '20'
                                 }
                             ]">
                             <!-- Corner points -->
                            <div class="absolute w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: getLabelColor(currentBox.label), top: '-3px', left: '-3px' }"></div>
                            <div class="absolute w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: getLabelColor(currentBox.label), top: '-3px', right: '-3px' }"></div>
                            <div class="absolute w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: getLabelColor(currentBox.label), bottom: '-3px', left: '-3px' }"></div>
                            <div class="absolute w-1.5 h-1.5 rounded-full" :style="{ backgroundColor: getLabelColor(currentBox.label), bottom: '-3px', right: '-3px' }"></div>
                        </div>
                    </template>
                    <div v-else class="text-gray-400 m-auto">æš‚æ— å›¾ç‰‡</div>
                    
                </div>
                <div class="mt-2 flex justify-between items-center">
                    <button @click="prevImage" :disabled="currentIndex <= 0" class="px-4 py-2 bg-gray-200 rounded disabled:opacity-50">â† ä¸Šä¸€å¼ </button>
                    <span class="font-mono">{{ currentImageName }}</span>
                    <button @click="nextImage" :disabled="currentIndex >= images.length - 1" class="px-4 py-2 bg-gray-200 rounded disabled:opacity-50">ä¸‹ä¸€å¼  â†’</button>
                </div>
            </div>

            <!-- Right Panel: Modes -->
            <div class="w-full md:w-1/3 bg-white p-4 rounded shadow flex flex-col gap-4 overflow-y-auto">
                <div class="flex border-b mb-2">
                    <button @click="rightMode = 'qa'" :class="['flex-1 py-2 text-sm font-medium', rightMode === 'qa' ? 'border-b-2 border-indigo-600 text-indigo-600' : 'text-gray-500']">
                        é—®ç­”æ ‡æ³¨
                    </button>
                    <button @click="rightMode = 'box'" :class="['flex-1 py-2 text-sm font-medium', rightMode === 'box' ? 'border-b-2 border-indigo-600 text-indigo-600' : 'text-gray-500']">
                        æ¡†é€‰æ ‡æ³¨
                    </button>
                </div>

                <!-- QA Mode -->
                <div v-if="rightMode === 'qa'" class="flex flex-col gap-4 flex-1">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">User Input (ç”¨æˆ·æŒ‡ä»¤)</label>
                        <div class="relative">
                            <textarea v-model="userContent" ref="userContentRef" rows="4" class="w-full border border-gray-300 rounded p-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="ä¾‹å¦‚: æè¿°è¿™å¼ å›¾ç‰‡..."></textarea>
                        </div>
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Assistant Output (åŠ©æ‰‹å›ç­”)</label>
                        <textarea v-model="assistantContent" rows="6" class="w-full border border-gray-300 rounded p-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="æ¨¡å‹é¢„æœŸçš„å›ç­”..."></textarea>
                    </div>

                    <div class="mt-auto pt-4 border-t flex flex-col gap-2">
                        <div v-if="saveStatus" :class="{'text-green-600': saveStatus.type === 'success', 'text-red-600': saveStatus.type === 'error'}" class="text-sm text-center mb-2">
                            {{ saveStatus.msg }}
                        </div>
                        <button @click="saveAndNext" class="w-full bg-indigo-600 text-white py-2 rounded font-bold hover:bg-indigo-700 transition flex justify-center items-center gap-2">
                            <span>ä¿å­˜å¹¶ä¸‹ä¸€å¼ </span>
                            <span class="text-xs font-normal opacity-75">(Ctrl + Enter)</span>
                        </button>
                        <button @click="nextImage" class="w-full bg-white border border-gray-300 text-gray-700 py-2 rounded hover:bg-gray-50">
                            è·³è¿‡ (ä¸ä¿å­˜)
                        </button>
                    </div>
                </div>

                <!-- Box Mode -->
                <div v-else class="flex flex-col gap-4 flex-1">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">å½“å‰æ¨¡å¼: æ¡†é€‰æ ‡æ³¨</label>
                        <p class="text-xs text-gray-500">
                            å…ˆåœ¨å³ä¾§å®šä¹‰ä¸€ç»„æ ‡ç­¾å¹¶é€‰æ‹©å½“å‰æ ‡ç­¾ï¼Œç‚¹å‡»â€œåˆ›å»ºBoxâ€åï¼Œåœ¨å›¾ç‰‡ä¸ŠæŒ‰ä½å·¦é”®æ‹–æ‹½ç”ŸæˆçŸ©å½¢æ¡†ã€‚
                        </p>
                    </div>

                    <div class="flex flex-col gap-3">
                        <div class="flex items-center gap-2 p-1.5 bg-gray-50 rounded-lg border border-gray-200 shadow-sm transition-colors focus-within:border-indigo-300 focus-within:ring-2 focus-within:ring-indigo-100">
                            <div class="text-gray-400 pl-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                                </svg>
                            </div>
                            <input v-model="labelInput" @keyup.enter="addLabel" placeholder="è¾“å…¥æ–°æ ‡ç­¾æŒ‰Enteræ·»åŠ ..." class="flex-1 bg-transparent border-none focus:ring-0 text-sm px-2 py-1 outline-none">
                            <button @click="addLabel" class="p-1.5 bg-white text-indigo-600 border border-gray-200 rounded-md hover:bg-indigo-50 hover:border-indigo-200 transition shadow-sm" title="æ·»åŠ æ ‡ç­¾">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                                </svg>
                            </button>
                        </div>
                        <div class="flex flex-wrap gap-2">
                            <button
                                v-for="(name, idx) in labelList"
                                :key="name"
                                @click="selectLabel(name)"
                                class="group relative px-3 py-1.5 text-xs font-medium rounded-lg border transition-all duration-200 flex items-center gap-2 shadow-sm hover:shadow"
                                :style="{
                                    backgroundColor: currentBoxLabel === name ? getLabelColor(name) : 'white',
                                    borderColor: currentBoxLabel === name ? getLabelColor(name) : '#e5e7eb',
                                    color: currentBoxLabel === name ? 'white' : '#374151'
                                }"
                            >
                                <span v-if="idx < 10" class="flex items-center justify-center w-4 h-4 rounded-full text-[10px] font-mono" :class="currentBoxLabel === name ? 'bg-black/20 text-white' : 'bg-gray-100 text-gray-500'">
                                    {{ idx === 9 ? 0 : idx + 1 }}
                                </span>
                                {{ name }}
                            </button>
                        </div>
                        <div class="flex items-center justify-between text-xs text-gray-500">
                            <span>å½“å‰æ ‡ç­¾:
                                <span class="font-medium text-indigo-600">
                                    {{ currentBoxLabel || 'æœªé€‰æ‹©' }}
                                </span>
                            </span>
                            <button @click="clearBoxes" class="px-3 py-1 text-xs border border-gray-300 rounded text-gray-600 hover:bg-gray-50">
                                æ¸…ç©ºæœ¬å›¾æ¡†
                            </button>
                        </div>
                        <div class="flex gap-2">
                            <button
                                @click="toggleBoxCreate"
                                :disabled="!currentImageName"
                                class="flex-1 px-4 py-2.5 text-sm rounded-lg font-medium transition-all shadow-sm disabled:opacity-50 flex justify-center items-center gap-2"
                                :class="boxCreateActive 
                                    ? 'bg-indigo-600 text-white ring-2 ring-indigo-300 ring-offset-1' 
                                    : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 hover:border-indigo-300 hover:text-indigo-600'"
                            >
                                <svg v-if="!boxCreateActive" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                                </svg>
                                <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 animate-pulse" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                                </svg>
                                {{ boxCreateActive ? 'æ­£åœ¨ç»˜åˆ¶... (ESCå–æ¶ˆ)' : 'å¼€å§‹åˆ›å»º Box' }}
                            </button>
                        </div>
                    </div>

                    <div class="flex-1 overflow-y-auto border border-gray-200 rounded p-2">
                        <div v-if="boxesForCurrentImage.length === 0" class="text-xs text-gray-400">
                            å½“å‰å›¾ç‰‡æš‚æ— æ¡†æ ‡æ³¨ã€‚è¯·åœ¨å›¾ç‰‡ä¸Šæ‹–åŠ¨ç»˜åˆ¶ã€‚
                        </div>
                        <div v-for="(b, idx) in boxesForCurrentImage" :key="idx" class="flex items-center justify-between text-xs py-1 border-b last:border-b-0">
                            <div class="flex-1 truncate">
                                <span class="font-medium text-indigo-600">{{ b.label || '(æœªå‘½å)' }}</span>
                                <span class="text-gray-500 ml-1">
                                    [{{ Math.round(b.x1) }}, {{ Math.round(b.y1) }}] - [{{ Math.round(b.x2) }}, {{ Math.round(b.y2) }}]
                                </span>
                            </div>
                            <button @click="removeBox(idx)" class="text-red-500 hover:text-red-700 ml-2">åˆ é™¤</button>
                        </div>
                    </div>

                    <div class="pt-4 border-t flex flex-col gap-2">
                        <div v-if="boxSaveStatus" :class="{'text-green-600': boxSaveStatus.type === 'success', 'text-red-600': boxSaveStatus.type === 'error'}" class="text-sm text-center mb-2">
                            {{ boxSaveStatus.msg }}
                        </div>
                        <button @click="saveBoxes" class="w-full bg-indigo-600 text-white py-2 rounded font-bold hover:bg-indigo-700 transition">
                            ä¿å­˜å½“å‰å›¾ç‰‡æ¡†æ ‡æ³¨
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const { createApp, ref, computed, onMounted, onUnmounted, watch, nextTick } = Vue;

createApp({
    setup() {
        const projects = ref([]);
        const currentProjectId = ref('');
        const projectForm = ref({ id: '', name: '', image_dir: '', jsonl_path: '' });
        
        const images = ref([]);
        const labeledSet = ref(new Set());
        const currentIndex = ref(0);
        const imageRef = ref(null);
        const imageContainerRef = ref(null);
        const drawingBoxRef = ref(null);
        
        const userContent = ref('è¯¦ç»†æè¿°è¿™å¼ å›¾ç‰‡ã€‚');
        const assistantContent = ref('');
        const saveStatus = ref(null);
        const userContentRef = ref(null);

        const rightMode = ref('box');

        const boxes = ref({});
        const drawing = ref(false);
        const startPoint = ref({ x: 0, y: 0 });
        const currentBox = ref(null);
        let tempBox = null; // Non-reactive for performance

        const currentBoxLabel = ref('');
        const boxSaveStatus = ref(null);
        const labelInput = ref('');
        const labelList = ref([]);
        const boxCreateActive = ref(false);
        const activePointerId = ref(null);
        const layoutVersion = ref(0);

        const labelColors = [
            '#ef4444', // red
            '#f97316', // orange
            '#f59e0b', // amber
            '#84cc16', // lime
            '#10b981', // emerald
            '#06b6d4', // cyan
            '#3b82f6', // blue
            '#6366f1', // indigo
            '#a855f7', // purple
            '#ec4899', // pink
        ];

        const getLabelColor = (label) => {
            if (!label) return '#9ca3af'; // gray-400
            const idx = labelList.value.indexOf(label);
            if (idx !== -1) {
                return labelColors[idx % labelColors.length];
            }
            // Hash for unknown labels
            let hash = 0;
            for (let i = 0; i < label.length; i++) {
                hash = label.charCodeAt(i) + ((hash << 5) - hash);
            }
            const c = (hash & 0x00ffffff).toString(16).toUpperCase();
            return '#' + '00000'.substring(0, 6 - c.length) + c;
        };

        const currentImageName = computed(() => {
            if (images.value.length > 0 && currentIndex.value >= 0 && currentIndex.value < images.value.length) {
                return images.value[currentIndex.value];
            }
            return null;
        });

        const boxesForCurrentImage = computed(() => {
            if (!currentImageName.value) return [];
            return boxes.value[currentImageName.value] || [];
        });

        const labeledCount = computed(() => labeledSet.value.size);
        const totalImages = computed(() => images.value.length);

        const getImageUrl = (name) => `./api/image_file/${encodeURIComponent(name)}`;
        const isLabeled = (name) => labeledSet.value.has(name);

        const fetchImages = async () => {
            try {
                const res = await fetch('./api/images');
                const data = await res.json();
                images.value = data.images;
                labeledSet.value = new Set(data.labeled);
                
                // Find first unlabeled image
                const firstUnlabeled = images.value.findIndex(img => !labeledSet.value.has(img));
                if (firstUnlabeled !== -1) {
                    currentIndex.value = firstUnlabeled;
                } else {
                    currentIndex.value = 0;
                }
            } catch (e) {
                console.error(e);
            }
        };

        const fetchProjects = async () => {
            try {
                const res = await fetch('./api/projects');
                projects.value = await res.json();
            } catch(e) { console.error(e); }
        };

        const onProjectSwitch = async () => {
             const pid = currentProjectId.value;
             if(!pid) return;
             const p = projects.value.find(x => x.id === pid);
             if(p) {
                 projectForm.value = { ...p };
                 await fetch(`./api/projects/switch/${pid}`, { method: 'POST' });
                 await fetchImages();
             }
        };

        const saveProject = async () => {
            if(!projectForm.value.name || !projectForm.value.image_dir || !projectForm.value.jsonl_path) {
                alert("è¯·å¡«å†™å®Œæ•´é¡¹ç›®ä¿¡æ¯");
                return;
            }
            try {
                const res = await fetch('./api/projects', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(projectForm.value)
                });
                if(res.ok) {
                    const newProject = await res.json();
                    await fetchProjects();
                    currentProjectId.value = newProject.id;
                    projectForm.value = { ...newProject };
                    await fetchImages();
                } else {
                    const err = await res.json();
                    alert(err.detail || "ä¿å­˜å¤±è´¥");
                }
            } catch(e) {
                alert("ä¿å­˜å¤±è´¥");
            }
        };

        const deleteProject = async () => {
            if(!currentProjectId.value) return;
            if(!confirm("ç¡®å®šè¦åˆ é™¤è¯¥é¡¹ç›®å—ï¼Ÿ")) return;
            try {
                await fetch(`./api/projects/${currentProjectId.value}`, { method: 'DELETE' });
                projectForm.value = { id: '', name: '', image_dir: '', jsonl_path: '' };
                currentProjectId.value = '';
                images.value = [];
                labeledSet.value = new Set();
                await fetchProjects();
            } catch(e) {
                alert("åˆ é™¤å¤±è´¥");
            }
        };
        
        const clearForm = () => {
            projectForm.value = { id: '', name: '', image_dir: '', jsonl_path: '' };
            currentProjectId.value = '';
            images.value = [];
        };

        const selectImageDir = async () => {
            try {
                const res = await fetch('./api/utils/select_folder');
                const data = await res.json();
                if (data.path) {
                    projectForm.value.image_dir = data.path;
                }
            } catch (e) {
                console.error(e);
            }
        };

        const selectJsonlPath = async () => {
            try {
                const res = await fetch('./api/utils/select_file_save');
                const data = await res.json();
                if (data.path) {
                    projectForm.value.jsonl_path = data.path;
                }
            } catch (e) {
                console.error(e);
            }
        };

        const selectImage = (index) => {
            currentIndex.value = index;
            assistantContent.value = '';
            saveStatus.value = null;
            drawing.value = false;
            currentBox.value = null;
            activePointerId.value = null;
        };

        const prevImage = () => {
            if (currentIndex.value > 0) selectImage(currentIndex.value - 1);
        };

        const nextImage = () => {
            if (currentIndex.value < images.value.length - 1) selectImage(currentIndex.value + 1);
        };

        const onImageLoad = () => {
            layoutVersion.value = layoutVersion.value + 1;
        };

        const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

        const getImageMetrics = () => {
            layoutVersion.value;
            const containerEl = imageContainerRef.value;
            const imgEl = imageRef.value;
            if (!containerEl || !imgEl) return null;

            const containerRect = containerEl.getBoundingClientRect();
            const imgRect = imgEl.getBoundingClientRect();

            if (imgRect.width <= 0 || imgRect.height <= 0) return null;
            if (!Number.isFinite(imgEl.naturalWidth) || !Number.isFinite(imgEl.naturalHeight)) return null;
            if (imgEl.naturalWidth <= 0 || imgEl.naturalHeight <= 0) return null;

            return {
                containerRect,
                imgRect,
                naturalWidth: imgEl.naturalWidth,
                naturalHeight: imgEl.naturalHeight
            };
        };

        const pointerEventToImagePixels = (e, opts = {}) => {
            const metrics = getImageMetrics();
            if (!metrics) return null;
            const { imgRect, naturalWidth, naturalHeight } = metrics;

            const inside =
                e.clientX >= imgRect.left &&
                e.clientX <= imgRect.right &&
                e.clientY >= imgRect.top &&
                e.clientY <= imgRect.bottom;

            if (opts.requireInside && !inside) return null;

            const xClampedClient = clamp(e.clientX, imgRect.left, imgRect.right);
            const yClampedClient = clamp(e.clientY, imgRect.top, imgRect.bottom);

            const xOnDisplayed = xClampedClient - imgRect.left;
            const yOnDisplayed = yClampedClient - imgRect.top;

            const x = (xOnDisplayed * naturalWidth) / imgRect.width;
            const y = (yOnDisplayed * naturalHeight) / imgRect.height;

            return {
                x: clamp(x, 0, naturalWidth),
                y: clamp(y, 0, naturalHeight)
            };
        };

        const boxStyleFromImagePixels = (box, zIndex, useMinSize = false) => {
            const metrics = getImageMetrics();
            if (!metrics) return { display: 'none' };

            const { containerRect, imgRect, naturalWidth, naturalHeight } = metrics;

            const leftOnImg = Math.min(box.x1, box.x2);
            const topOnImg = Math.min(box.y1, box.y2);
            const widthOnImg = Math.abs(box.x2 - box.x1);
            const heightOnImg = Math.abs(box.y2 - box.y1);

            const offsetX = imgRect.left - containerRect.left;
            const offsetY = imgRect.top - containerRect.top;
            const scaleX = imgRect.width / naturalWidth;
            const scaleY = imgRect.height / naturalHeight;

            const left = offsetX + leftOnImg * scaleX;
            const top = offsetY + topOnImg * scaleY;
            const width = widthOnImg * scaleX;
            const height = heightOnImg * scaleY;

            return {
                zIndex,
                left: left + 'px',
                top: top + 'px',
                width: (useMinSize ? Math.max(1, width) : width) + 'px',
                height: (useMinSize ? Math.max(1, height) : height) + 'px'
            };
        };

        const onImagePointerDown = async (e) => {
            if (rightMode.value !== 'box') return;
            if (!boxCreateActive.value) return;
            if (e.pointerType === 'mouse' && e.button !== 0) return;
            if (!currentImageName.value) return;
            if (!currentBoxLabel.value) {
                boxSaveStatus.value = { type: 'error', msg: 'è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ ‡ç­¾ï¼Œå†åˆ›å»ºBox' };
                return;
            }
            if (!imageContainerRef.value) return;
            if (!imageRef.value) return;
            e.preventDefault();

            const pos = pointerEventToImagePixels(e, { requireInside: true });
            if (!pos) return;
            if (drawing.value) return;

            boxSaveStatus.value = null;
            drawing.value = true;
            activePointerId.value = e.pointerId;
            startPoint.value = pos;
            
            const initBox = { x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y, label: currentBoxLabel.value };
            currentBox.value = initBox;
            tempBox = { ...initBox };

            imageContainerRef.value.setPointerCapture(e.pointerId);
            
            await nextTick();
            if (drawingBoxRef.value) {
                const style = boxStyleFromImagePixels(tempBox, 20, true);
                Object.assign(drawingBoxRef.value.style, style);
            }
        };

        const onImagePointerMove = (e) => {
            if (!drawing.value) return;
            if (activePointerId.value !== null && e.pointerId !== activePointerId.value) return;
            const pos = pointerEventToImagePixels(e);
            if (!pos) return;
            
            if (tempBox) {
                tempBox.x2 = pos.x;
                tempBox.y2 = pos.y;
                
                if (drawingBoxRef.value) {
                    const style = boxStyleFromImagePixels(tempBox, 20, true);
                    Object.assign(drawingBoxRef.value.style, style);
                }
            }
        };

        const finishDrawing = () => {
            if (!drawing.value || !tempBox || !currentImageName.value) {
                drawing.value = false;
                currentBox.value = null;
                tempBox = null;
                activePointerId.value = null;
                return;
            }
            const box = tempBox;
            if (Math.abs(box.x2 - box.x1) < 3 || Math.abs(box.y2 - box.y1) < 3) {
                drawing.value = false;
                currentBox.value = null;
                tempBox = null;
                activePointerId.value = null;
                return;
            }
            const img = currentImageName.value;
            const list = boxes.value[img] ? [...boxes.value[img]] : [];
            list.push({ x1: box.x1, y1: box.y1, x2: box.x2, y2: box.y2, label: box.label });
            boxes.value = { ...boxes.value, [img]: list };
            drawing.value = false;
            currentBox.value = null;
            tempBox = null;
            activePointerId.value = null;
        };

        const onImagePointerUp = (e) => {
            if (!drawing.value) return;
            if (activePointerId.value !== null && e.pointerId !== activePointerId.value) return;
            
            const pos = pointerEventToImagePixels(e);
            if (pos && tempBox) {
                tempBox.x2 = pos.x;
                tempBox.y2 = pos.y;
            }

            if (imageContainerRef.value && activePointerId.value !== null) {
                try { imageContainerRef.value.releasePointerCapture(activePointerId.value); } catch {}
            }
            finishDrawing();
        };

        const onImagePointerCancel = (e) => {
            if (!drawing.value) return;
            if (activePointerId.value !== null && e.pointerId !== activePointerId.value) return;
            if (imageContainerRef.value && activePointerId.value !== null) {
                try { imageContainerRef.value.releasePointerCapture(activePointerId.value); } catch {}
            }
            drawing.value = false;
            currentBox.value = null;
            tempBox = null;
            activePointerId.value = null;
        };

        const onImagePointerLeave = () => {
            return;
        };

        const clearBoxes = () => {
            if (!currentImageName.value) return;
            boxes.value = { ...boxes.value, [currentImageName.value]: [] };
        };

        const removeBox = (idx) => {
            if (!currentImageName.value) return;
            const list = boxesForCurrentImage.value.slice();
            if (idx < 0 || idx >= list.length) return;
            list.splice(idx, 1);
            boxes.value = { ...boxes.value, [currentImageName.value]: list };
        };

        const addLabel = () => {
            const name = labelInput.value.trim();
            if (!name) return;
            if (!labelList.value.includes(name)) {
                labelList.value.push(name);
            }
            labelInput.value = '';
            currentBoxLabel.value = name;
        };

        const selectLabel = (name) => {
            currentBoxLabel.value = name;
        };

        const toggleBoxCreate = () => {
            boxCreateActive.value = !boxCreateActive.value;
            if (!boxCreateActive.value) {
                drawing.value = false;
                currentBox.value = null;
                activePointerId.value = null;
            }
        };

        const insertTag = (tag) => {
            const textarea = userContentRef.value;
            if (!textarea) return;
            
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = userContent.value;
            
            userContent.value = text.substring(0, start) + tag + text.substring(end);
            
            // Restore focus and cursor
            setTimeout(() => {
                textarea.focus();
                textarea.setSelectionRange(start + tag.length, start + tag.length);
            }, 0);
        };

        const saveAndNext = async () => {
            if (!currentImageName.value) return;
            if (!assistantContent.value.trim()) {
                saveStatus.value = { type: 'error', msg: 'åŠ©æ‰‹å›ç­”ä¸èƒ½ä¸ºç©º' };
                return;
            }

            try {
                const res = await fetch('./api/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: currentImageName.value,
                        user_content: userContent.value,
                        assistant_content: assistantContent.value
                    })
                });

                if (res.ok) {
                    labeledSet.value.add(currentImageName.value);
                    saveStatus.value = { type: 'success', msg: 'ä¿å­˜æˆåŠŸ!' };
                    setTimeout(() => {
                        saveStatus.value = null;
                        nextImage();
                    }, 500);
                } else {
                    throw new Error('Save failed');
                }
            } catch (e) {
                saveStatus.value = { type: 'error', msg: 'ä¿å­˜å¤±è´¥: ' + e.message };
            }
        };

        // Keyboard shortcuts
        const handleKeydown = (e) => {
            // Allow Ctrl+Enter from anywhere to save
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault(); // Prevent default newline in textarea
                saveAndNext();
                return;
            }

            // For navigation keys, ensure we are not typing in an input/textarea
            const target = e.target;
            const isTyping = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;
            
            if (!isTyping) {
                switch(e.key.toLowerCase()) {
                    case 'a':
                        prevImage();
                        break;
                    case 'd':
                        nextImage();
                        break;
                }
                
                // Shortcut for labels (1-9, 0)
                if (/^[0-9]$/.test(e.key)) {
                    const num = parseInt(e.key);
                    const idx = num === 0 ? 9 : num - 1;
                    if (idx < labelList.value.length) {
                        const label = labelList.value[idx];
                        currentBoxLabel.value = label;
                        // Auto activate box creation
                        if (!boxCreateActive.value) {
                            toggleBoxCreate();
                        }
                        boxSaveStatus.value = { type: 'success', msg: `å·²é€‰ä¸­æ ‡ç­¾: ${label} (å¿«æ·é”® ${num})` };
                        setTimeout(() => { 
                            if(boxSaveStatus.value && boxSaveStatus.value.msg.includes(label)) 
                                boxSaveStatus.value = null; 
                        }, 1500);
                    }
                }
            }
        };

        const saveBoxes = async () => {
            if (!currentImageName.value) return;
            const list = boxesForCurrentImage.value;
            if (!list || list.length === 0) {
                boxSaveStatus.value = { type: 'error', msg: 'å½“å‰å›¾ç‰‡æ²¡æœ‰æ¡†å¯ä»¥ä¿å­˜' };
                return;
            }
            try {
                const res = await fetch('./api/save_boxes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: currentImageName.value,
                        boxes: list
                    })
                });
                if (res.ok) {
                    boxSaveStatus.value = { type: 'success', msg: 'æ¡†æ ‡æ³¨å·²ä¿å­˜' };
                    setTimeout(() => {
                        boxSaveStatus.value = null;
                    }, 800);
                } else {
                    const err = await res.json();
                    boxSaveStatus.value = { type: 'error', msg: err.detail || 'ä¿å­˜å¤±è´¥' };
                }
            } catch (e) {
                boxSaveStatus.value = { type: 'error', msg: 'ä¿å­˜å¤±è´¥: ' + e.message };
            }
        };

        onMounted(async () => {
            await fetchProjects();
            if (projects.value.length > 0) {
                currentProjectId.value = projects.value[0].id;
                await onProjectSwitch();
            }
            window.addEventListener('keydown', handleKeydown);
            window.addEventListener('resize', onImageLoad);
        });

        onUnmounted(() => {
            window.removeEventListener('keydown', handleKeydown);
            window.removeEventListener('resize', onImageLoad);
        });

        return {
            projects, currentProjectId, projectForm, 
            saveProject, deleteProject, onProjectSwitch, clearForm, fetchImages,
            selectImageDir, selectJsonlPath,
            images, currentIndex, 
            userContent, assistantContent, saveStatus, userContentRef,
            currentImageName, labeledCount, totalImages,
            getImageUrl, isLabeled, selectImage, 
            prevImage, nextImage, insertTag, saveAndNext,
            imageRef, imageContainerRef, drawingBoxRef, onImageLoad,
            rightMode,
            labelInput, labelList, currentBoxLabel, boxesForCurrentImage, boxSaveStatus,
            boxes, drawing, currentBox,
            clearBoxes, removeBox, addLabel, selectLabel, saveBoxes,
            boxCreateActive, toggleBoxCreate,
            boxStyleFromImagePixels,
            getLabelColor,
            onImagePointerDown, onImagePointerMove, onImagePointerUp, onImagePointerCancel, onImagePointerLeave
        };
    }
}).mount('#app');
</script>
</body>
</html>
